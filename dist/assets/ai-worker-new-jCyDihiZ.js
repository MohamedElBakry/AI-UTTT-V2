var H=Object.defineProperty;var F=(g,i,y)=>i in g?H(g,i,{enumerable:!0,configurable:!0,writable:!0,value:y}):g[i]=y;var M=(g,i,y)=>(F(g,typeof i!="symbol"?i+"":i,y),y);(function(){"use strict";class g{constructor(o,e,r,n,c){M(this,"board");M(this,"subBoardStates");M(this,"previousMove");M(this,"turn");this.board=c?o.map(f=>f.slice(0)):o,this.subBoardStates=c?e.map(f=>f.slice(0)):e,this.previousMove=r,this.turn=n}}const i={none:0,X:1,O:2,gameOver:!1,draw:!1},y=9,B=new Array(y).fill(i.none),O=[[0,0,0],[0,0,0],[0,0,0]],I=B.map(()=>B.slice(0));new g(I,O,null,i.O,!1);const k=[i.X,i.O],A=[[[0,0],[0,1],[0,2]],[[1,0],[1,1],[1,2]],[[2,0],[2,1],[2,2]]],w=[[[0,0],[1,0],[2,0]],[[0,1],[1,1],[2,1]],[[0,2],[1,2],[2,2]]],N=[[[0,0],[1,1],[2,2]],[[0,2],[1,1],[2,0]]],h=A.concat(w).concat(N);function E(u){for(let o=0;o<Math.floor(y/3);o++)for(let e=0;e<Math.floor(y/3);e++){u.subBoardStates[e][o]=i.none;for(const r of h){let n=P(u.board,r,o,e);if(n&&(u.subBoardStates[e][o]=n,n!=i.none))break}}}function P(u,o,e,r){let n=null;return u[o[0][0]+r*3][o[0][1]+e*3]==i.X&&u[o[1][0]+r*3][o[1][1]+e*3]==i.X&&u[o[2][0]+r*3][o[2][1]+e*3]==i.X?n=i.X:u[o[0][0]+r*3][o[0][1]+e*3]==i.O&&u[o[1][0]+r*3][o[1][1]+e*3]==i.O&&u[o[2][0]+r*3][o[2][1]+e*3]==i.O&&(n=i.O),n}function W(u){for(const o of k)for(let e=0;e<h.length;e++)if(u[h[e][0][0]][h[e][0][1]]==o&&u[h[e][1][0]][h[e][1][1]]==o&&u[h[e][2][0]][h[e][2][1]]==o)return o}function X(u,o,e){const r=e*3,n=o*3;let c=[];for(const f of u.filter((a,s)=>s==r||s==r+1||s==r+2))c=c.concat(f.filter((a,s)=>s>=n&&s<n+3));return c}function C(u,o,e){if(e.previousMove===null)return!0;if(e.board[u][o]!=i.none)return!1;const n=R(u,o),c=x(e.previousMove.x,e.previousMove.y),f=n.x==c.x&&n.y==c.y,a=e.subBoardStates[n.x][n.y]==i.none;if(X(e.board,c.y,c.x).every(l=>l==i.X||l==i.O))return!0;const s=e.subBoardStates[c.x][c.y]==i.none;return a&&!f&&!s?!0:!(!a||!f)}function R(u,o){const e=Math.floor(u/3),r=Math.floor(o/3);return{x:e,y:r}}function x(u,o){const e=u%3,r=o%3;return{x:e,y:r}}const b=class b{constructor(o,e,r=b.piece.X,n=!1){M(this,"state");M(this,"type");M(this,"piece");M(this,"opponentPiece");M(this,"workers");this.state=o,this.type=e,this.piece=r,this.opponentPiece=r===b.piece.X?b.piece.O:r}static workerFrom(o){const e=JSON.parse(o);return new b(e.state,e.type,e.piece,!0)}static getLegalMoves(o){const e=[];for(let r=0;r<o.board.length;r++)for(let n=0;n<o.board.length;n++)C(n,r,o)&&e.push({x:n,y:r});return e}simulateMove(o,e){return o.board[e.x][e.y]=this.piece,o.previousMove=e,o=new g(o.board,o.subBoardStates,o.previousMove,o.turn,!0),o}async getScoresFromThreads(o,e,r){const n=[];let c=0;const f=new Promise((a,s)=>{for(const l of r)l.onmessage=t=>{c++;const[d,v]=t.data;typeof d=="number"&&(n.push([d,v]),c===o.length&&a([n]))}});for(let a=0;a<o.length;a++)r[a%r.length].postMessage(o[a]);return f}async generateOptimalMove(o=6,e,r=this.state){const n=o,c=4;let f=-1/0,a,s=new g(r.board,r.subBoardStates,r.previousMove,r.turn,!0);const l=b.getLegalMoves(s);o=l.length<=9?n:c;const t=[];for(const v of l){const p=s.previousMove;s=this.simulateMove(s,v),t.push([JSON.stringify(this),o,JSON.parse(JSON.stringify(s)),-1/0,1/0,!1,v]),s.board[v.x][v.y]=i.none,s.previousMove=p}console.time("threaded");const[d]=await this.getScoresFromThreads(t,navigator.hardwareConcurrency,e);console.timeEnd("threaded");for(const[v,p]of d)v>f&&(f=v,a=p),console.log("Moves with their scores:",p,v);return f==-1/0&&(a=l[l.length-1]),console.log("Move selected at",a,"with score",f,"at depth",o,"— cores:",navigator.hardwareConcurrency),a}async generateOptimalMoveSingleThreaded(o=6,e=this.state){const r=o,n=4;let c=-1/0,f,a=new g(e.board,e.subBoardStates,e.previousMove,e.turn,!0);console.time("ai best move reply time");const s=b.getLegalMoves(a);o=s.length<=9?r:n;let l=0;for(const t of s){l++,a.board[t.x][t.y]=this.piece;const d=a.previousMove;a=this.simulateMove(a,t);const v=this.miniMaxAlphaBetaPruning(o,a,-1/0,1/0,!1);a.board[t.x][t.y]=i.none,a.previousMove=d,console.log(t,`Score (${l}/${s.length}):`,v),v>c&&(c=v,f=t)}return c==-1/0&&(f=s[s.length-1]),console.timeEnd("ai best move reply time"),console.log("Move selected at",f,"with score",c,"at depth",o,"— cores:","singled threaded"),f}evaluate(o=this.state){let e=null;const r=[[!1,!1,!1],[!1,!1,!1],[!1,!1,!1]],n=[],c=2;n[0]=0,n[this.piece]=c,n[this.opponentPiece]=-c;for(let t=0;t<3;t++)for(let d=0;d<3;d++)for(const v of h){let p=P(o.board,v,d,t);p===this.piece?e+=100:p===this.opponentPiece&&(e-=100);var f=o.board[v[0][0]+d*3][v[0][1]+t*3],a=o.board[v[1][0]+d*3][v[1][1]+t*3],s=o.board[v[2][0]+d*3][v[2][1]+t*3],l=n[f]+n[a]+n[s];Math.abs(l)>n[this.piece]&&(e+=l,r[d][t]=!0),l=0}for(let t=0;t<h.length;t++){let d=o.subBoardStates[h[t][0][0]][h[t][0][1]],v=o.subBoardStates[h[t][1][0]][h[t][1][1]],p=o.subBoardStates[h[t][2][0]][h[t][2][1]],m=n[d]+n[v]+n[p];Math.abs(m)>n[this.piece]&&(e+=m),m=0}for(let t=0;t<y;t++)for(let d=0;d<y;d++){const v=o.board[t][d],p=x(t,d),m=o.subBoardStates[p.x][p.y],T=r[p.x][p.y];(m!=i.none||T)&&(v==this.piece?e-=50:v==this.opponentPiece&&(e+=50))}return e}miniMaxAlphaBetaPruning(o,e,r,n,c){E(e);const f=W(e.subBoardStates);if(f===this.opponentPiece)return-1/0;if(f===this.piece)return 1/0;const a=this.evaluate(e);if(o===0)return a;if(e=new g(e.board,e.subBoardStates,e.previousMove,e.turn,!0),c){let s=-1/0;for(const l of b.getLegalMoves(e)){const t=e.previousMove;e.board[l.x][l.y]=this.piece,e.previousMove=l;const d=this.miniMaxAlphaBetaPruning(o-1,e,r,n,!1);if(e.board[l.x][l.y]=i.none,e.previousMove=t,s=Math.max(s,d),r=Math.max(r,d),n<=r)break}return s}else if(!c){let s=1/0;for(const l of b.getLegalMoves(e)){const t=e.previousMove;e.board[l.x][l.y]=this.opponentPiece,e.previousMove=l;const d=this.miniMaxAlphaBetaPruning(o-1,e,r,n,!0);if(e.board[l.x][l.y]=i.none,e.previousMove=t,s=Math.min(s,d),n=Math.min(n,d),n<=r)break}return s}}};M(b,"type",{MINIMAX_ALPHA_BETA_PRUNING:0}),M(b,"piece",{X:1,O:2});let S=b;onmessage=u=>{const o=S.workerFrom(u.data[0]),[e,r,n,c,f,a]=u.data.slice(1,u.data.length),s=o.miniMaxAlphaBetaPruning(e,r,n,c,f);postMessage([s,a])}})();
