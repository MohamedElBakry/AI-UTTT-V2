var T=Object.defineProperty;var F=(M,u,g)=>u in M?T(M,u,{enumerable:!0,configurable:!0,writable:!0,value:g}):M[u]=g;var b=(M,u,g)=>(F(M,typeof u!="symbol"?u+"":u,g),g);(function(){"use strict";class M{constructor(o,e,r,n,i){b(this,"board");b(this,"subBoardStates");b(this,"previousMove");b(this,"moveHistory");b(this,"turn");this.board=i?o.map(l=>l.slice(0)):o,this.subBoardStates=i?e.map(l=>l.slice(0)):e,this.previousMove=r,this.moveHistory=new Array,this.turn=n}undo(){if(this.moveHistory.length===0)return;const{turn:o,x:e,y:r}=this.moveHistory.pop();this.board[e][r]=0;const{turn:n,x:i,y:l}=this.moveHistory.pop();if(this.turn=2,this.previousMove={x:i,y:l},this.board[i][l]=0,console.log(this.moveHistory),this.moveHistory.length===0){this.previousMove=null;return}const{x:a,y:s}=this.moveHistory[this.moveHistory.length-1];this.previousMove={x:a,y:s}}redo(){}reset(o){this.board=this.board.map(e=>e.fill(0)),this.subBoardStates=this.subBoardStates.map(e=>e.fill(0)),this.previousMove=null,this.turn=o}}const u={none:0,X:1,O:2,gameOver:!1,draw:!1},g=9,B=new Array(g).fill(u.none),O=[[0,0,0],[0,0,0],[0,0,0]],H=B.map(()=>B.slice(0));new M(H,O,null,u.O,!1);const I=[u.X,u.O],w=[[[0,0],[0,1],[0,2]],[[1,0],[1,1],[1,2]],[[2,0],[2,1],[2,2]]],k=[[[0,0],[1,0],[2,0]],[[0,1],[1,1],[2,1]],[[0,2],[1,2],[2,2]]],A=[[[0,0],[1,1],[2,2]],[[0,2],[1,1],[2,0]]],d=w.concat(k).concat(A);function N(c){for(let o=0;o<Math.floor(g/3);o++)for(let e=0;e<Math.floor(g/3);e++){c.subBoardStates[e][o]=u.none;for(const r of d){let n=x(c.board,r,o,e);if(n&&(c.subBoardStates[e][o]=n,n!=u.none))break}}}function x(c,o,e,r){let n=null;return c[o[0][0]+r*3][o[0][1]+e*3]==u.X&&c[o[1][0]+r*3][o[1][1]+e*3]==u.X&&c[o[2][0]+r*3][o[2][1]+e*3]==u.X?n=u.X:c[o[0][0]+r*3][o[0][1]+e*3]==u.O&&c[o[1][0]+r*3][o[1][1]+e*3]==u.O&&c[o[2][0]+r*3][o[2][1]+e*3]==u.O&&(n=u.O),n}function X(c){for(const o of I)for(let e=0;e<d.length;e++)if(c[d[e][0][0]][d[e][0][1]]==o&&c[d[e][1][0]][d[e][1][1]]==o&&c[d[e][2][0]][d[e][2][1]]==o)return o}function E(c,o,e){const r=e*3,n=o*3;let i=[];for(const l of c.filter((a,s)=>s==r||s==r+1||s==r+2))i=i.concat(l.filter((a,s)=>s>=n&&s<n+3));return i}function W(c,o,e){if(c<0||c>8||o<0||o>8)return!1;if(e.previousMove===null)return!0;if(e.board[c][o]!=u.none)return!1;const n=C(c,o),i=P(e.previousMove.x,e.previousMove.y),l=n.x==i.x&&n.y==i.y,a=e.subBoardStates[n.x][n.y]==u.none;if(E(e.board,i.y,i.x).every(f=>f==u.X||f==u.O))return!0;const s=e.subBoardStates[i.x][i.y]==u.none;return a&&!l&&!s?!0:!(!a||!l)}function C(c,o){const e=Math.floor(c/3),r=Math.floor(o/3);return{x:e,y:r}}function P(c,o){const e=c%3,r=o%3;return{x:e,y:r}}const y=class y{constructor(o,e,r=y.piece.X,n=!1){b(this,"state");b(this,"type");b(this,"piece");b(this,"opponentPiece");b(this,"workers");this.state=o,this.type=e,this.piece=r,this.opponentPiece=r===y.piece.X?y.piece.O:r}static workerFrom(o){const e=JSON.parse(o);return new y(e.state,e.type,e.piece,!0)}static getLegalMoves(o){const e=[];for(let r=0;r<o.board.length;r++)for(let n=0;n<o.board.length;n++)W(n,r,o)&&e.push({x:n,y:r});return e}simulateMove(o,e){return o.board[e.x][e.y]=this.piece,o.previousMove=e,o=new M(o.board,o.subBoardStates,o.previousMove,o.turn,!0),o}async getScoresFromThreads(o,e,r){const n=[];let i=0;const l=new Promise((a,s)=>{for(const f of r)f.onmessage=t=>{i++;const[h,v]=t.data;typeof h=="number"&&(n.push([h,v]),i===o.length&&a([n]))}});for(let a=0;a<o.length;a++)r[a%r.length].postMessage(o[a]);return l}async generateOptimalMove(o=6,e,r=this.state){const n=o,i=4;let l=-1/0,a,s=new M(r.board,r.subBoardStates,r.previousMove,r.turn,!0);const f=y.getLegalMoves(s);o=f.length<=9?n:i;const t=[];for(const v of f){const p=s.previousMove;s=this.simulateMove(s,v),t.push([JSON.stringify(this),o,JSON.parse(JSON.stringify(s)),-1/0,1/0,!1,v]),s.board[v.x][v.y]=u.none,s.previousMove=p}console.time("threaded");const[h]=await this.getScoresFromThreads(t,navigator.hardwareConcurrency,e);console.timeEnd("threaded");for(const[v,p]of h)v>l&&(l=v,a=p),console.log("Moves with their scores:",p,v);return l==-1/0&&(a=f[f.length-1]),console.log("Move selected at",a,"with score",l,"at depth",o,"— cores:",navigator.hardwareConcurrency),a}async generateOptimalMoveSingleThreaded(o=6,e=this.state){const r=o,n=4;let i=-1/0,l,a=new M(e.board,e.subBoardStates,e.previousMove,e.turn,!0);console.time("ai best move reply time");const s=y.getLegalMoves(a);o=s.length<=9?r:n;let f=0;for(const t of s){f++,a.board[t.x][t.y]=this.piece;const h=a.previousMove;a=this.simulateMove(a,t);const v=this.miniMaxAlphaBetaPruning(o,a,-1/0,1/0,!1);a.board[t.x][t.y]=u.none,a.previousMove=h,console.log(t,`Score (${f}/${s.length}):`,v),v>i&&(i=v,l=t)}return i==-1/0&&(l=s[s.length-1]),console.timeEnd("ai best move reply time"),console.log("Move selected at",l,"with score",i,"at depth",o,"— cores:","singled threaded"),l}evaluate(o=this.state){let e=null;const r=[[!1,!1,!1],[!1,!1,!1],[!1,!1,!1]],n=[],i=2;n[0]=0,n[this.piece]=i,n[this.opponentPiece]=-i;for(let t=0;t<3;t++)for(let h=0;h<3;h++)for(const v of d){let p=x(o.board,v,h,t);p===this.piece?e+=100:p===this.opponentPiece&&(e-=100);var l=o.board[v[0][0]+h*3][v[0][1]+t*3],a=o.board[v[1][0]+h*3][v[1][1]+t*3],s=o.board[v[2][0]+h*3][v[2][1]+t*3],f=n[l]+n[a]+n[s];Math.abs(f)>n[this.piece]&&(e+=f,r[h][t]=!0),f=0}for(let t=0;t<d.length;t++){let h=o.subBoardStates[d[t][0][0]][d[t][0][1]],v=o.subBoardStates[d[t][1][0]][d[t][1][1]],p=o.subBoardStates[d[t][2][0]][d[t][2][1]],m=n[h]+n[v]+n[p];Math.abs(m)>n[this.piece]&&(e+=m),m=0}for(let t=0;t<g;t++)for(let h=0;h<g;h++){const v=o.board[t][h],p=P(t,h),m=o.subBoardStates[p.x][p.y],R=r[p.x][p.y];(m!=u.none||R)&&(v==this.piece?e-=50:v==this.opponentPiece&&(e+=50))}return e}miniMaxAlphaBetaPruning(o,e,r,n,i){N(e);const l=X(e.subBoardStates);if(l===this.opponentPiece)return-1/0;if(l===this.piece)return 1/0;const a=this.evaluate(e);if(o===0)return a;if(e=new M(e.board,e.subBoardStates,e.previousMove,e.turn,!0),i){let s=-1/0;for(const f of y.getLegalMoves(e)){const t=e.previousMove;e.board[f.x][f.y]=this.piece,e.previousMove=f;const h=this.miniMaxAlphaBetaPruning(o-1,e,r,n,!1);if(e.board[f.x][f.y]=u.none,e.previousMove=t,s=Math.max(s,h),r=Math.max(r,h),n<=r)break}return s}else if(!i){let s=1/0;for(const f of y.getLegalMoves(e)){const t=e.previousMove;e.board[f.x][f.y]=this.opponentPiece,e.previousMove=f;const h=this.miniMaxAlphaBetaPruning(o-1,e,r,n,!0);if(e.board[f.x][f.y]=u.none,e.previousMove=t,s=Math.min(s,h),n=Math.min(n,h),n<=r)break}return s}}};b(y,"type",{MINIMAX_ALPHA_BETA_PRUNING:0}),b(y,"piece",{X:1,O:2});let S=y;onmessage=c=>{const o=S.workerFrom(c.data[0]),[e,r,n,i,l,a]=c.data.slice(1,c.data.length),s=o.miniMaxAlphaBetaPruning(e,r,n,i,l);postMessage([s,a])}})();
